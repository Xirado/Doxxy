package com.freya02.bot.tag

import com.freya02.bot.db.DBAction
import com.freya02.bot.db.Database
import com.freya02.botcommands.api.core.annotations.BService
import kotlinx.coroutines.runBlocking
import net.dv8tion.jda.api.entities.Message
import net.dv8tion.jda.api.interactions.commands.build.OptionData
import java.sql.ResultSet
import java.sql.SQLException

@BService
class TagDB(private val database: Database) {
    private fun checkName(name: String) {
        if (name.length > NAME_MAX_LENGTH)
            throw TagException("Tag name is too long, it should be under $NAME_MAX_LENGTH characters")
        if (name.length < NAME_MIN_LENGTH)
            throw TagException("Tag name is too small, it should be above $NAME_MIN_LENGTH characters")
    }

    private fun checkDescription(description: String) {
        if (description.length > DESCRIPTION_MAX_LENGTH)
            throw TagException("Tag description is too long, it should be under $DESCRIPTION_MAX_LENGTH characters")
        if (description.length < DESCRIPTION_MIN_LENGTH)
            throw TagException("Tag description is too small, it should be above $DESCRIPTION_MIN_LENGTH characters")
    }

    private fun checkContent(content: String) {
        if (content.length > CONTENT_MAX_LENGTH)
            throw TagException("Tag content is too long, it should be under $CONTENT_MAX_LENGTH characters")
        if (content.length < CONTENT_MIN_LENGTH)
            throw TagException("Tag content is too small, it should be above $CONTENT_MIN_LENGTH characters")
    }

    @Throws(SQLException::class)
    fun create(guildId: Long, ownerId: Long, name: String, description: String, content: String) {
        DBAction.of(
            database,
            "insert into Tag (guildid, ownerid, name, description, content) values (?, ?, ?, ?, ?)"
        ).use { action ->
            checkName(name)
            checkDescription(description)
            checkContent(content)
            action.executeUpdate(guildId, ownerId, name, description, content)
        }
    }

    @Throws(SQLException::class)
    fun edit(
        guildId: Long,
        ownerId: Long,
        name: String,
        newName: String,
        newDescription: String,
        newContent: String
    ) = runBlocking {
        checkName(newName)
        checkDescription(newDescription)
        checkContent(newContent)

        database.transactional {
            preparedStatement(
                """
                    update Tag
                    set name        = coalesce(?, name),
                        description = coalesce(?, description),
                        content     = coalesce(?, content)
                    where guildid = ?
                      and ownerid = ?
                      and name = ?""".trimIndent()
            ) {
                executeUpdate(newName, newDescription, newContent, guildId, ownerId, name)
            }
        }
    }

    @Throws(SQLException::class)
    fun transfer(guildId: Long, ownerId: Long, name: String, newOwnerId: Long) {
        DBAction.of(
            database,
            "update Tag set ownerId = ? where guildid = ? and ownerid = ? and name = ?"
        ).use { action -> action.executeUpdate(newOwnerId, guildId, ownerId, name) }
    }

    @Throws(SQLException::class)
    fun delete(guildId: Long, ownerId: Long, name: String) {
        DBAction.of(
            database,
            "delete from Tag where guildid = ? and ownerid = ? and name = ?"
        ).use { action -> action.executeUpdate(guildId, ownerId, name) }
    }

    @Throws(SQLException::class)
    operator fun get(guildId: Long, name: String): Tag? {
        DBAction.of(
            database,
            "select * from Tag where guildid = ? and name = ?",
            *Tag.COLUMN_NAMES
        ).use { action ->
            val result = action.executeQuery(guildId, name)
            return result.readOnce { set: ResultSet -> Tag.fromResult(set) }
        }
    }

    @Throws(SQLException::class)
    fun incrementTag(guildId: Long, name: String) {
        DBAction.of(
            database,
            "update Tag set uses = uses + 1 where guildid = ? and name = ?"
        ).use { action -> action.executeUpdate(guildId, name) }
    }

    @Throws(SQLException::class)
    fun getTotalTags(guildId: Long): Int {
        DBAction.of(
            database,
            "select count(*) as totalTags from Tag where guildid = ?",
            "totalTags"
        ).use { action ->  //Can't use column index on autogenerated values
            val result = action.executeQuery(guildId)
            val set = result.readOnce() ?: throw IllegalStateException()
            return set.getInt("totalTags")
        }
    }

    @Throws(SQLException::class)
    fun getTagRange(guildId: Long, criteria: TagCriteria, offset: Int, amount: Int): List<Tag> {
        DBAction.of(
            database,
            "select * from Tag where guildid = ? order by ${criteria.key} offset ? limit ?",
            *Tag.COLUMN_NAMES
        ).use { action ->
            val result = action.executeQuery(guildId, offset, amount)
            return result.transformEach { set: ResultSet -> Tag.fromResult(set) }
        }
    }

    @Throws(SQLException::class)
    fun getShortTagsSorted(guildId: Long, criteria: TagCriteria): List<ShortTag> {
        DBAction.of(
            database,
            "select name, description from Tag where guildid = ? order by ${criteria.key}",
            *ShortTag.COLUMN_NAMES
        ).use { action ->
            val result = action.executeQuery(guildId)
            return result.transformEach { set: ResultSet -> ShortTag.fromResult(set) }
        }
    }

    @Throws(SQLException::class)
    fun getShortTagsSorted(guildId: Long, ownerId: Long, criteria: TagCriteria): List<ShortTag> {
        DBAction.of(
            database,
            "select name, description from Tag where guildid = ? and ownerid = ? order by ${criteria.key}",
            *ShortTag.COLUMN_NAMES
        ).use { action ->
            val result = action.executeQuery(guildId, ownerId)
            return result.transformEach { set: ResultSet -> ShortTag.fromResult(set) }
        }
    }

    @Throws(SQLException::class)
    fun getRank(guildId: Long, name: String?): Long {
        DBAction.of(
            database,
            "select rank from (select name, dense_rank() over (order by uses desc) as rank from Tag where guildid = ?) as ranks where name = ?",
            "rank"
        ).use { action ->  //Can't use column index on autogenerated values
            val result = action.executeQuery(guildId, name)
            val set = result.readOnce() ?: throw IllegalStateException()
            return set.getLong(1)
        }
    }

    companion object {
        const val NAME_MIN_LENGTH = 2
        const val NAME_MAX_LENGTH = OptionData.MAX_CHOICE_NAME_LENGTH
        const val DESCRIPTION_MIN_LENGTH = 10
        const val DESCRIPTION_MAX_LENGTH = 512
        const val CONTENT_MIN_LENGTH = 1
        const val CONTENT_MAX_LENGTH = Message.MAX_CONTENT_LENGTH
    }
}